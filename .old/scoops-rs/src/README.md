# The `main.rs` file

You've got to remember that *Scoops*, as a programming language, is not just a
bunch of syntactic rules -- it is also how they are **implemented**. Long story
short, when you compile this whole project into a binary file `scoops.exe` or
just `scoops` (for those not on Windows) it is that binary file that is
responsible for reading and executing your *Scoops* scripts and its entry point
is the [`main.rs`](./main.rs) file right here. Thus, if you want to understand
how *Scoops* actually works, this is the first file you must examine.



## Background

When you run your *Python* files (for example) in a terminal, using this command

```bash
python3 main.py
```

what happens behind the curtains is far from magic. In this case, `python3` is
just a binary program, originally written in and compiled from the 
*C prorgramming language*. That binary file is stored in some location like 
`/usr/bin/python3`; that location is stored in the 
`$PATH` [environment variable][env-var] so that when you press **ENTER**, your
operating system knows where to look for it -- it knows that `python3` is not
stored in the current folder since you've ommitted the `./` prefix.

[env-var]: https://en.wikipedia.org/wiki/Environment_variable

If you were to run `./python3 main.py` as opposed to `python3 main.py`, your OS
would think that this `python3` executable is somewhere in the current 
folder -- it would quickly get upset about being unable to find it üò≠üò¢üòì.

So anyways, what that executable actually does is as follows:

1. It accepts your `main.py` file as an input and reads its contents,
2. compiles everything it reads into a simpler intermediate language called [*bytecode*][bytecode],
3. starts up [Python Virtual Machine (PVM)][VM] that accepts *bytecode* and executes it, producing output.

[bytecode]: https://www.synopsys.com/blogs/software-security/understanding-python-bytecode/
[VM]: https://www.ibm.com/cloud/learn/virtual-machines

That is what I would call *Python's execution pipeline*. Many interpreted
programming languages, *Scoops* included, do roughly the same thing, and it's
important to understand how this *pipeline* works in order to understand how
*Scoops* works.



## Scoops Execution Pipeline

We wanted to make *Scoops* as flexible as possible, allowing you to have
multiple ways of using and storing your code. *Scoops' execution pipeline*
totally reflects these design choices. Yet, for now, we'll examine the most
common and subsequently the most revealing mode of use: **script execution**.

Suppose that you have your *Scoops* script stored in some file we'll call
`main.scp`. Here's how it might look like:

```scoops
# The `main.scp` file (Source Code)

var a int = 5
print(a)
```

Let's examine what happens when we try to execute it using

```bash
scoops main.scp
```

Here's a brief overview:

```
‚îÇ Source Code ‚áí Scoops Assembly Code (Compilation phase)
‚îú‚îÄ‚îÄ‚îÄ‚î¨ Reading `main.scp` file
‚îÇ   ‚îú Lexical analysis
‚îÇ   ‚îú Syntactic analysis
‚îÇ   ‚îú Semantic analysis
‚îÇ   ‚îî Assembly Code generation
‚îÇ
‚îÇ Scoops Assembly Code ‚áí Bytecode (Assembling phase)
‚îú‚îÄ‚îÄ‚îÄ‚î¨ Using generated Assembly Code
‚îÇ   ‚îî Almost one-to-one translation to Scoops Bytecode
‚îÇ
‚îÇ Bytecode ‚áí Output (Execution phase)
‚îî‚îÄ‚îÄ‚îÄ‚î¨ Starting up the Scoops Virtual Machine
    ‚îú Using generated Bytecode
    ‚îú Instruction-by-instruction evaluation
    ‚îî Producing output
```


### Compilation Phase

comp phase


### Assembling Phase

asm phase


### Execution Phase

exec phase



## Scoops + Terminal = ‚ù§Ô∏è

One of the main ways of executing *Scoops* scripts is through the Terminal;
It is important to understand how that process works.

### Compile and Assemble

When you've installed *Scoops* onto your machine, you will inevitably want to
use it. When you've finished writing your first script,

```scoops
# Your first script. File named `hello.scp`

print("hello world")
```

there are a few things you can do with it. First of all, you don't have to
execute right away. You may want to play with *Scoops Assembly* and
*Scoops Bytecode* -- the source code files with `*.scp` extension can be
compiled into both. To compile your file, you need to run the following command:

```bash
scoops hello.scp _hello.scpa
```

That underscore prefix tells *Scoops*, without any additional flags, that your
current intention is **not** to execute this code -- what you actually want is
to translate your `hello.scp` source code file into the *Scoops Assembly* form.
That operation is called **compilation** in *Scoops*. That prefix is not going
to be in the name of that output file though -- it's only there so that we know
it apart from any command line argument you want to pass to your script. For
example, the following line wouldn't trigger and compiling.

```bash
scoops hello.scp hello.scpa
```

In this case, `hello.scpa` is going to be accessible to your script as a
command line argument. If you were to run that command, *Scoops* would execute
your script and print *hello world* to `stdout`.

Now that you have `hello.scpa` file, you can **assemble** it to get `hello.scpb`
*bytecode* file. You already know how to assemble it, don't you?

```bash
scoops hello.scpa _hello.scpb
```

If you manage to open the resulting `hello.scpb` with [Atom][Atom] or 
[VIM][VIM], you won't be able to read it because it is a binary file meant to
be understood only by the *Scoops Virtual Machine*. Yet, `hello.scpa` is pretty
readable. By the way, you can also make *Scoops* **compile and assemble** your
source code for you in one go(!) and it is as simple as just assembling or just
compiling:

```bash
scoops hello.scpa _hello.scpb
```

[Atom]: https://atom.io
[VIM]: https://www.vim.org


### Let's Execute!

Now that you've looked at all the intermediate stages of code transformation
pipeline, you can relax and execute it al last. You are lucky -- any *Scoops*
file can be executed no matter the extension. This means that you can run all of
the following commands and they will produce the same result, as they are just
different representations of the same program!

```bash
scoops hello.scp    # execute from source code
scoops hello.scpa   # execute from Scoops assembly code
scoops hello.scpb   # execute from Scoops bytecode
```
